<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Probabilistische Datenwissenschaft für die Psychologie - 1&nbsp; Sprache und Logik</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Referenzen.html" rel="next">
<link href="./index.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./101-Sprache-und-Logik.html">Mathematische Grundlagen</a></li><li class="breadcrumb-item"><a href="./101-Sprache-und-Logik.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sprache und Logik</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Probabilistische Datenwissenschaft für die Psychologie</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/dirk-ostwald/dirk-ostwald.github.io/tree/gh-pages" title="Quellcode" class="quarto-navigation-tool px-1" aria-label="Quellcode"><i class="bi bi-github"></i></a>
    <a href="./Probabilistische-Datenwissenschaft-für-die-Psychologie.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Willkommen</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Mathematische Grundlagen</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./101-Sprache-und-Logik.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sprache und Logik</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Referenzen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referenzen</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#sec-mathematik-ist-eine-sprache" id="toc-sec-mathematik-ist-eine-sprache" class="nav-link active" data-scroll-target="#sec-mathematik-ist-eine-sprache"><span class="header-section-number">1.1</span> Mathematik ist eine Sprache</a></li>
  <li><a href="#sec-grundbausteine-mathematischer-kommunikation" id="toc-sec-grundbausteine-mathematischer-kommunikation" class="nav-link" data-scroll-target="#sec-grundbausteine-mathematischer-kommunikation"><span class="header-section-number">1.2</span> Grundbausteine mathematischer Kommunikation</a></li>
  <li><a href="#sec-aussagenlogik" id="toc-sec-aussagenlogik" class="nav-link" data-scroll-target="#sec-aussagenlogik"><span class="header-section-number">1.3</span> Aussagenlogik</a></li>
  <li><a href="#sec-beweistechniken" id="toc-sec-beweistechniken" class="nav-link" data-scroll-target="#sec-beweistechniken"><span class="header-section-number">1.4</span> Beweistechniken</a></li>
  <li><a href="#sec-selbstkontrollfragen-sprache-und-logik" id="toc-sec-selbstkontrollfragen-sprache-und-logik" class="nav-link" data-scroll-target="#sec-selbstkontrollfragen-sprache-und-logik"><span class="header-section-number">1.5</span> Selbstkontrollfragen</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/dirk-ostwald/dirk-ostwald.github.io/tree/gh-pages/edit/main/101-Sprache-und-Logik.qmd" class="toc-action"><i class="bi bi-github"></i>Seite editieren</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./101-Sprache-und-Logik.html">Mathematische Grundlagen</a></li><li class="breadcrumb-item"><a href="./101-Sprache-und-Logik.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sprache und Logik</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-sprache-und-logik" class="quarto-section-identifier"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sprache und Logik</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-mathematik-ist-eine-sprache" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="sec-mathematik-ist-eine-sprache"><span class="header-section-number">1.1</span> Mathematik ist eine Sprache</h2>
<p>Mathematik ist die Sprache der naturwissenschaftlichen Modellbildung. So entspricht zum Beispiel der Ausdruck <span class="math display">\[\begin{equation}
F = ma
\end{equation}\]</span> im Sinne des zweiten Newtonschen Axioms einer Theorie zur Bewegung von Objekten unter der Einwirkung von Kräften (<span class="citation" data-cites="newton1687">Newton (<a href="#ref-newton1687" role="doc-biblioref">1687</a>)</span>). Gleichermaßen entspricht der Ausdruck <span class="math display">\[\begin{equation}
\max_{q(z)} \int q(z) \ln \left(\frac{p(y,z)}{q(z)}\right)\,dz
\end{equation}\]</span> im Sinne der Variational Inference der zeitgenössischen Theorie zur Funktionsweise des Gehirns (<span class="citation" data-cites="friston2005">Friston (<a href="#ref-friston2005" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="friston2023">Friston et al. (<a href="#ref-friston2023" role="doc-biblioref">2023</a>)</span>, <span class="citation" data-cites="ostwald2014">Ostwald et al. (<a href="#ref-ostwald2014" role="doc-biblioref">2014</a>)</span>, <span class="citation" data-cites="blei2017">Blei et al. (<a href="#ref-blei2017" role="doc-biblioref">2017</a>)</span>). Mathematische Symbolik dient dabei insbesondere der genauen Kommunikation wissenschaftlicher Erkenntnisse und zielt darauf ab, komplexe Sachverhalte exakt und effizient zu beschreiben. Wie beim reflektierten Umgang mit jeder Form von Sprache steht also die Frage “Was soll das heißen?” als Leitfrage im Umgang mit mathematischen Inhalten und Symbolismen immer im Vordergrund.</p>
<p>Als Sprachgebäude weist die Mathematik einige Besonderheiten auf. Zum einen sind ihre Inhalte oft abstrakt. Dies rührt daher, dass sich die Mathematik um eine möglichst breite Allgemeinverständlichkeit und Anwendbarkeit bemüht. Mathematische Zugänge zu den Phänomenen der Welt sind dabei an einer möglichst einfache Transferierbarkeit von Erkenntnissen in andere Kontexte interessiert. Um dies zu ermöglichen, versucht die Mathematik möglichst genau und verständlich, also im Sinne präziser Begriffsbildungen zu arbeiten. Sie geht dabei insbesondere streng hierarchisch vor, so dass an späterer Stelle eingeführte Begrifflichkeiten oft ein gutes Verständnis der ihnen zugrundeliegenden und an früherer Stelle eingeführten Begrifflichkeiten voraussetzen.</p>
<p>Die Genauigkeit der mathematischen Sprache impliziert dabei eine hohe Informationsdichte. Sie ist daher eher nüchtern und lässt überflüssiges weg, so dass in mathematischen Texten im besten Fall <em>alles</em> für die Kommunikation einer Idee relevant ist. Als Rezipient:in mathematischer Texte nimmt man die Informationsdichte mathematischer Texte anhand des hohen Verbrauchs an kognitiver Energie beim Lesen eines Textes wahr. Dieser hohe Energieverbrauch gebietet insbesondere Ruhe und Langsamkeit bei einem auf ein gutes Verständnis abzielenden Lesen. Als Leitsatz im Umgang mit mathematischen Texten mag dabei folgendes Zitat dienen: “Einen mathematischen Text kann man nicht lesen wie einen Roman, man muss ihn sich erarbeiten” (<span class="citation" data-cites="unger2000">Unger (<a href="#ref-unger2000" role="doc-biblioref">2000</a>)</span>). Nach dem Lesen eines kurzen mathematischen Textes sollte man sich immer kritisch fragen, ob man das Gelesene wirklich verstanden hat oder ob man zur Klärung des Sachverhaltes weitere Quellen heranziehen sollte. Auch ist es hilfreich, sich im Sinne des berühmten Zitats “What I cannot create, I do not understand” von Richard Feynman eigene Aufzeichnungen anzufertigen und mathematische Sprachgebäude selbst nachzubauen.</p>
<p>Möchte man sich also die Welt der naturwissenschaftliche Modellbildung erschließen, so ist es hilfreich, beim Umgang mit ihrer mathematischen Ausdrucksweise und Symbolik die gleichen Strategien wie beim Erlernen einer Fremdsprache anzuwenden. Hierzu gehört neben dem Eintauchen in den entsprechenden Sprachraum, also der ständige Exposition mit mathematischen Ausdrucksweisen, sicherlich auch zunächst einmal das Auswendiglernen von Begriffen und das aktive Lesen und das Übersetzen von Texten in die Alltagssprache. Ein tiefes und sicheres Verständnis mathematischer Modellbildung ergibt sich dann insbesondere durch die Anwendung mathematischer Herangehensweisen in schriftlicher und mündlicher Form.</p>
</section>
<section id="sec-grundbausteine-mathematischer-kommunikation" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="sec-grundbausteine-mathematischer-kommunikation"><span class="header-section-number">1.2</span> Grundbausteine mathematischer Kommunikation</h2>
<p>In diesem Abschnitt stellen wir mit den Begriffen der <em>Definition</em>, des <em>Theorems</em> und des <em>Beweises</em> drei Grundbausteine mathematischer Kommunikation vor, die uns durchgängig begleiten.</p>
<p><strong>Definition</strong></p>
<p>Eine <em>Definition</em> ist eine Grundannahme eines mathematischen Systems, die innerhalb dieses Systems weder begründet noch deduktiv abgeleitet wird. Definitionen können nur nach ihrer Nützlichkeit innerhalb eines mathematischen Systems bewertet werden. Eine Definition lernt man am besten erst einmal auswendig und hinterfragt sie erst dann, wenn man ihren Nutzen in der Anwendung verstanden hat oder von diesem nicht überzeugt ist. Etwas Entspannung und Ruhe beim Umgang mit auf den ersten Blick komplexen Definitionen ist generell hilfreich. Um zu kennzeichnen, dass wir ein Symbol als etwas definieren, nutzen wir die Schreibweise “<span class="math inline">\(:=\)</span>”. Zum Beispiel definiert der Ausdruck “<span class="math inline">\(a := 2\)</span>” das Symbol <span class="math inline">\(a\)</span> als die Zahl Zwei. Definitionen enden in diesem Text immer mit dem Symbol <span class="math inline">\(\bullet\)</span>.</p>
<p><strong>Theorem</strong></p>
<p>Ein <em>Theorem</em> ist eine mathematische Aussage, die mittels eines Beweises als wahr (richtig) erkannt werden kann. Dass heißt, ein Theorem wird immer aus Definitionen und/oder anderen Theoremen hergeleitet. Theoreme sind in diesem Sinne die empirischen Ergebnisse der Mathematik. Im Deutschen werden Theoreme auch oft als <em>Sätze</em> bezeichnet. In der angewandten, datenanalytischen Mathematik sind Theoreme oft für Berechnungen hilfreich. Es lohnt sich also, sie auswendig zu lernen, da sie meist die Grundlage für Datenauswertung und Dateninterpretation bilden. Oft tauchen in Theoremen Gleichungen auf. Diese ergeben sich dabei aus den Voraussetzungen des Theorems. Um Gleichungen zu kennzeichnen nutzen wir das Gleichheitszeichen “<span class="math inline">\(=\)</span>”. So besagt also zum Beispiel der Ausdruck “<span class="math inline">\(a = 2\)</span>” in einem gegebenen Kontext, dass aufgrund bestimmter Voraussetzungen das Symbol oder die Variable <span class="math inline">\(a\)</span> den Wert zwei hat. Theoreme enden in diesem Text immer mit dem Symbol <span class="math inline">\(\circ\)</span>.</p>
<p><strong>Beweis</strong></p>
<p>Ein <em>Beweis</em> ist eine logische Argumentationskette, die auf bekannte Definitionen und Theoreme zurückgreift, um die Wahrheit (Richtigkeit) eines Theorems zu belegen. Kurze Beweise tragen dabei oft zum Verständnis eines Theorems bei, lange Beweise eher nicht. Beweise sind also insbesondere die Antwort auf die Frage, warum eine mathematische Aussage gilt (“Warum ist das so?”). Beweise lernt man nicht auswendig. Wenn Beweise kurz sind, ist es sinnvoll, sie durchzuarbeiten, da sie meist als bekannt vorausgesetzte Inhalte wiederholen. Wenn sie lang sind, ist es sinnvoller sie zunächst zu übergehen, um sich nicht in Details zu verlieren und vom eigentlichen Weg durch das entsprechende mathematische Gebäude abzukommen. Beweise enden in diesem Text immer mit dem Symbol <span class="math inline">\(\Box\)</span>.</p>
<p>Neben den oben vorgestellten Begriffen gibt es mit <em>Axiomen</em>, <em>Lemmata</em>, <em>Korollaren</em> und <em>Vermutungen</em> noch weitere typische Grundbausteine mathematischer Texte. Wir werden diese Begriff nicht verwenden und geben deshalb für sie nur einen kurzen Überblick.</p>
<p><em>Axiome</em> sind unbeweisbare Theoreme, in dem Sinne, als dass sie als Grundannahmen zum Aufbau mathematischer Systeme dienen. Der Übergang zwischen Definitionen und Axiomen ist dabei oft fließend. Da wir mathematisch nicht besonders tief arbeiten, bevorzugen wir in den allermeisten Fällen den Begriff der Definition.</p>
<p>Ein <em>Lemma</em> ist ein “Hilfstheorem”, also eine mathematische Aussage, die zwar bewiesen wird, aber nicht so bedeutend ist wie ein Theorem. Da wir einerseits auf bedeutende Inhalte fokussieren und andererseits mathematische Aussagen nicht diskriminieren wollen, verzichten wir auf diesen Begriff und nutzen stattdessen den Begriff des Theorems.</p>
<p>Ein <em>Korollar</em> ist eine mathematische Aussage, die sich durch einen einfachen Beweis aus einem Theorem ergibt. Da die “Einfachheit” mathematischer Beweise eine relative Eigenschaft ist, verzichten wir auf diesen Begriff und nutzen stattdessen auch hier den Begriff des Theorems.</p>
<p><em>Vermutungen</em> sind mathematische Aussagen von denen unbekannt ist, ob sie beweisbar oder widerlegbar sind. Da wir im Bereich der angewandten Mathematik arbeiten, treffen wir nicht auf Vermutungen.</p>
</section>
<section id="sec-aussagenlogik" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="sec-aussagenlogik"><span class="header-section-number">1.3</span> Aussagenlogik</h2>
<p>Nachdem wir nun einige Grundbausteine mathematischer Modellbildung kennengelernt haben, wollen wir uns mit der <em>Aussagenlogik</em> einem einfachem System nähern, das es erlaubt, Beziehungen zwischen mathematischen Aussagen herzustellen und zu formalisieren. Im Folgenden spielt die Aussagenlogik zum Beispiel in der Definition von Mengenoperationen, bei Optimierungsbedingungen von Funktionen und in vielen Beweisen einen tragende Rolle. In der mathematischen Anwendung ist Aussagenlogik die Grundlage der Booleschen Logik der Programmierung. In der mathematischen Psychologie ist die Aussagenlogik zum Beispiel die Grundlage der Repräsentationstheorie des Messens.</p>
<p>Wir beginnen mit der Definition des Begriffs der mathematischen <em>Aussage</em>.</p>
<div id="def-aussage" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.1 (Aussage)</strong></span> Eine ist ein Satz, dem eindeutig die Eigenschaft oder zugeordnet werden kann.</p>
</div>
<p>Das Adjektiv <em>wahr</em> kann auch als <em>richtig</em> verstanden werden. Wir kürzen wahr mit “w” und falsch mit “f” ab. Im Körper der reellen Zahlen ist zum Beispiel die Aussage <span class="math inline">\(1 + 1 = 2\)</span> wahr und die Aussage <span class="math inline">\(1 + 1 = 3\)</span> falsch. Man beachte, dass die Binärität des Wahrheitsgehalts von Aussagen eine Grundannahme der Aussagenlogik und damit formal wissenschaftlich und nicht empirisch zu verstehen ist. Wahrheitsgehalte beziehen sich nicht auf Definitionen, Definitionen sind immer wahr. Eine erste Möglichkeit, mit Aussagen zu arbeiten, ist, sie zu negieren. Dies führt auf folgende Definition.</p>
<div id="def-negation" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.2 (Negation)</strong></span> <span class="math inline">\(A\)</span> sei eine Aussage. Dann ist die die Aussage, die falsch ist, wenn <span class="math inline">\(A\)</span> wahr ist und die wahr ist, wenn <span class="math inline">\(A\)</span> falsch ist. Die Negation von <span class="math inline">\(A\)</span> wird mit <span class="math inline">\(\neg A\)</span>, gesprochen als “nicht <span class="math inline">\(A\)</span>”, bezeichnet.</p>
</div>
<p>Beispielsweise ist die Negation der Aussage “Die Sonne scheint” die Aussage “Die Sonne scheint nicht”. Die Negation der Aussage <span class="math inline">\(1 + 1 = 2\)</span> ist die Aussage <span class="math inline">\(1 + 1 \neq 2\)</span> und die Negation der Aussage <span class="math inline">\(x&gt;1\)</span> ist die Aussage <span class="math inline">\(x \le 1\)</span>. Tabellarisch stellt man die Definition der Negation einer Aussage <span class="math inline">\(A\)</span> wie folgt dar.</p>
<p>Tabellen dieser Form nennt man <em>Wahrheitstafeln</em>. Sie sind ein beliebtes Hilfsmittel in der Aussagenlogik. Möchte man zwei Aussagen logisch verbinden, so bieten sich zunächst die Begriffe der <em>Konjunktion</em> und <em>Disjunktion</em> an.</p>
<div id="def-konjunktion" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.3 (Konjunktion)</strong></span> <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> seien Aussagen. Dann ist die die Aussage, die dann und nur dann wahr ist, wenn <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> beide wahr sind. Die Konjunktion von <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> wird mit <span class="math inline">\(A \land B\)</span>, gesprochen als “<span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span>”, bezeichnet.</p>
</div>
<p>Die Definition der Konjunktion impliziert folgende Wahrheitstafel.</p>
<p>Als Beispiel sei <span class="math inline">\(A\)</span> die Aussage <span class="math inline">\(2\ge1\)</span> und <span class="math inline">\(B\)</span> die Aussage <span class="math inline">\(2&gt;1\)</span>. Da sowohl <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> wahr sind, ist auch die Aussage <span class="math inline">\(2 \ge 1 \land 2 &gt; 1\)</span> wahr. Als weiteres Beispiel sei <span class="math inline">\(A\)</span> die Aussage <span class="math inline">\(1\ge 1\)</span> und <span class="math inline">\(B\)</span> die Aussage <span class="math inline">\(1&gt;1\)</span>. Hier ist nun <span class="math inline">\(A\)</span> wahr und <span class="math inline">\(B\)</span> falsch. Also ist die Aussage <span class="math inline">\(1 \ge 1 \land 1 &gt; 1\)</span> falsch.</p>
<div id="def-disjunktion" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.4 (Disjunktion)</strong></span> <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> seien Aussagen. Dann ist die die Aussage, die dann und nur dann wahr ist, wenn mindestens eine der beiden Aussagen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> wahr ist. Die Disjunktion von <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> wird mit <span class="math inline">\(A \lor B\)</span>, gesprochen als “<span class="math inline">\(A\)</span> oder <span class="math inline">\(B\)</span>”, bezeichnet.</p>
</div>
<p>Die Definition der Disjunktion impliziert folgende Wahrheitstafel</p>
<p><span class="math inline">\(A \lor B\)</span> ist also insbesondere auch dann wahr, wenn <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> beide wahr sind. Damit ist das hier betrachtete “oder” genauer ein “und/oder”. Man nennt die Disjunktion daher auch ein “nicht-exklusives oder”. Als Beispiel sei <span class="math inline">\(A\)</span> die Aussage <span class="math inline">\(2\ge1\)</span> und <span class="math inline">\(B\)</span> die Aussage <span class="math inline">\(2&gt;1\)</span>. <span class="math inline">\(A\)</span> ist wahr und <span class="math inline">\(B\)</span> ist wahr. Also ist die Aussage <span class="math inline">\(2 \ge 1 \lor 2 &gt; 1\)</span> wahr. Sei nun wiederrum <span class="math inline">\(A\)</span> die Aussage <span class="math inline">\(1\ge 1\)</span> wahr und <span class="math inline">\(B\)</span> die Aussage <span class="math inline">\(1&gt;1\)</span>. Dann ist <span class="math inline">\(A\)</span> wahr und <span class="math inline">\(B\)</span> falsch. Also ist die Aussage <span class="math inline">\(1 \ge 1 \lor 1 &gt; 1\)</span> wahr.</p>
<p>Eine Möglichkeit, Aussagen in einen mechanischen logischen Zusammenhang zu stellen, ist die <em>Implikation</em>. Diese ist wie folgt definiert.</p>
<div id="def-implikation" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.5 (Implikation)</strong></span> <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> seien Aussagen. Dann ist die , bezeichnet mit <span class="math inline">\(A \Rightarrow B\)</span>, die Aussage, die dann und nur dann falsch ist, wenn <span class="math inline">\(A\)</span> wahr und <span class="math inline">\(B\)</span> falsch ist. <span class="math inline">\(A\)</span> heißt dabei die und <span class="math inline">\(B\)</span> der der Implikation. <span class="math inline">\(A \Rightarrow B\)</span> spricht man als “aus <span class="math inline">\(A\)</span> folgt <span class="math inline">\(B\)</span>”, “<span class="math inline">\(A\)</span> impliziert <span class="math inline">\(B\)</span>”, oder “wenn <span class="math inline">\(A\)</span>, dann <span class="math inline">\(B\)</span>”.</p>
</div>
<p>Man mag <span class="math inline">\(\Rightarrow\)</span> auch als “daraus folgt” lesen. Die Definition der Implikation impliziert folgende Wahrheitstafel.</p>
<p>Ein Verständnis der Definition der Implikation im Sinne obiger Wahrheitstafel ergibt sich am ehesten, indem man sie als Versuch liest, die intuitive Vorstellung einer Folgerung im Kontext der Aussagenlogik abzubilden und zu formalisieren. Betrachtet man obige Wahrheitstafel unter diesem Gesichtspunkt, so sieht man, dass wenn <span class="math inline">\(A\)</span> wahr ist und <span class="math inline">\(A \Rightarrow B\)</span> wahr ist, <span class="math inline">\(B\)</span> wahr ist. Konstruiert man basierend auf einer wahren Aussage also (zum Beispiel durch das Umformen von Gleichungen) eine wahre Implikation so folgt, dass auch <span class="math inline">\(B\)</span> wahr ist. Ist dies nicht möglich (dass also gilt, wenn <span class="math inline">\(A\)</span> wahr ist, dass <span class="math inline">\(A \Rightarrow B\)</span> immer falsch ist), dann ist auch <span class="math inline">\(B\)</span> falsch. So mag man Aussagen widerlegen. Schließlich sieht man, dass wenn <span class="math inline">\(A\)</span> falsch ist und <span class="math inline">\(A \Rightarrow B\)</span> wahr ist, <span class="math inline">\(B\)</span> wahr oder falsch sein kann. Aus einer wahren Voraussetzung folgt also nur bei wahrer Implikation eine wahre Konklusion. Insbesondere genügt die Definition der Implikation damit der Forderung “Aus Falschem folgt beliebiges (ex falso sequitur quodlibet)”. Aus falschen Aussagen kann man also mithilfe der Implikation nichts richtiges folgern.</p>
<p>Im Kontext der Implikation ergeben sich die Begriffe der <em>hinreichenden</em> und der <em>notwendigen Aussagen (Bedingungen)</em>. Diese sind definiert wie folgt: wenn <span class="math inline">\(A \Rightarrow B\)</span> wahr ist, sagt man “<span class="math inline">\(A\)</span> ist <em>hinreichend</em> für <span class="math inline">\(B\)</span>” und “<span class="math inline">\(B\)</span> ist <em>notwendig</em> für <span class="math inline">\(A\)</span>”. Diese Sprachregelung erklärt sich folgendermaßen. Wenn <span class="math inline">\(A \Rightarrow B\)</span> wahr ist, gilt dass, wenn <span class="math inline">\(A\)</span> wahr ist auch <span class="math inline">\(B\)</span> wahr ist. Die Wahrheit von <span class="math inline">\(A\)</span> reicht also für die Wahrheit von <span class="math inline">\(B\)</span> aus. <span class="math inline">\(A\)</span> ist also hinreichend (ausreichend) für <span class="math inline">\(B\)</span>. Weiterhin gilt, dass wenn <span class="math inline">\(A \Rightarrow B\)</span> wahr ist, dass wenn <span class="math inline">\(B\)</span> falsch ist, dann auch <span class="math inline">\(A\)</span> falsch ist. Die Wahrheit von <span class="math inline">\(B\)</span> ist also für die Wahrheit von <span class="math inline">\(A\)</span> notwendig.</p>
<p>Eine sehr häufig autretender Zusammenhang zwischen zwei Aussagen ist ihre <em>Äquivalenz</em>.</p>
<div id="def-äquivalenz" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.6 (Äquivalenz)</strong></span> <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> seien Aussagen. Die ist die Aussage, die dann und nur dann wahr ist,wenn <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> beide wahr sind oder wenn <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> beide falsch sind. Die Äquivalenz von <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> wird mit <span class="math inline">\(A \Leftrightarrow B\)</span> bezeichnet und gesprochen als “<span class="math inline">\(A\)</span> genau dann wenn <span class="math inline">\(B\)</span>” oder “<span class="math inline">\(A\)</span> ist äquivalent zu <span class="math inline">\(B\)</span>”.</p>
</div>
<p>Die Definition der Äquivalenz impliziert folgende Wahrheitstafel</p>
<p>Die Definition des Begriffes der <em>logischen Äquivalenz</em> erlaubt es unter anderem, die Äquivalenz zweier Aussagen mithilfe von Implikationen nachzuweisen.</p>
<div id="def-logische-äquivalenz" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.7 (Logische Äquivalenz)</strong></span> Zwei Aussagen heißen , wenn ihre Wahrheitstafeln gleich sind.</p>
</div>
<p>Als Beispiele für logische Äquivalenzen, die häufig in Beweisargumentationen genutzt werden, zeigen wir folgendes Theorem.</p>
<div id="thm-logische-äquivalenzen" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1.1 (Logische Äquivalenzen)</strong></span> &nbsp;</p>
<span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> seien zwei Aussagen. Dann sind folgende Aussagen logisch äquivalent
</div>
<div class="proof">
<p><span class="proof-title"><em>Beweis</em>. </span>Nach Definition des Begriffs der logischen Äquivalenz müssen wir zeigen, dass die Wahrheitstafeln der betrachteten Aussagen gleich sind. Wir zeigen erst (1), dann (2).</p>
<p>(1) Wir erinnern an die Wahrheitstafel von <span class="math inline">\(A \Leftrightarrow B\)</span>:</p>
<p>Wir betrachten weiterhin die Wahrheitstafel von <span class="math inline">\((A \Rightarrow B) \land (B \Rightarrow A)\)</span>:</p>
<p>Der Vergleich der Wahrheitstafel von <span class="math inline">\(A \Leftrightarrow\)</span> mit den ersten beiden und der letzten Spalte der Wahrheitstafel von <span class="math inline">\((A \Rightarrow B) \land (B \Rightarrow A)\)</span> zeigt ihre Gleichheit.</p>
<p>(2) Wir erinnern an die Wahrheitstafel von <span class="math inline">\(A \Rightarrow B\)</span>:</p>
<p>Wir betrachten weiterhin die Wahrheitstafel von <span class="math inline">\((\neg B) \Rightarrow (\neg A)\)</span>:</p>
<p>Der Vergleich der Wahrheitstafel von <span class="math inline">\(A \Rightarrow B\)</span> mit den ersten beiden und der letzten Spalte der Wahrheitstafel von <span class="math inline">\((\neg B) \Rightarrow (\neg A)\)</span> zeigt ihre Gleichheit.</p>
</div>
<p>Die erste Aussage von <a href="#thm-logische-äquivalenzen" class="quarto-xref">Theorem&nbsp;<span>1.1</span></a> besagt, dass die Aussage “<span class="math inline">\(A\)</span> und”<span class="math inline">\(B\)</span> sind äquivalent” logisch äquivalent zur Aussage “Aus <span class="math inline">\(A\)</span> folgt <span class="math inline">\(B\)</span>” und aus “<span class="math inline">\(B\)</span> folgt <span class="math inline">\(A\)</span>” ist. Dies ist die Grundlage für viele sogenannte <em>direkte Beweise</em> mithilfe von Äquivalenzumformungen. Die zweite Aussage von <a href="#thm-logische-äquivalenzen" class="quarto-xref">Theorem&nbsp;<span>1.1</span></a> besagt, dass die Aussage “Aus <span class="math inline">\(A\)</span> folgt”<span class="math inline">\(B\)</span>” logisch äquivalent zur Aussage “Aus nicht <span class="math inline">\(B\)</span> folgt nicht <span class="math inline">\(A\)</span>” ist. Dies ist die Grundlage für die Technik des <em>indirekten Beweises</em>.</p>
</section>
<section id="sec-beweistechniken" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="sec-beweistechniken"><span class="header-section-number">1.4</span> Beweistechniken</h2>
<p>Im letzten Abschnitt wollen wir mit den Begriffen der <em>direkten</em> und <em>indirekten Beweise</em> sowie des <em>Beweises durch Widerspruch</em> kurz drei Beweistechniken skizzieren, von denen vor allem die erste in diesem Text immer wieder zur Begründung von Theoremen herangezogen wird. Dabei haben typische Theoreme die Form <span class="math inline">\(A \Rightarrow B\)</span> für Aussagen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span>.</p>
<p>Es gilt dabei</p>
<ul>
<li><em>Direkte Beweise</em> nutzen Äquivalenzumformungen, um <span class="math inline">\(A \Rightarrow B\)</span> zu zeigen.</li>
<li><em>Indirekte Beweise</em> nutzen die logische Äquivalenz von <span class="math inline">\(A \Rightarrow B\)</span> und <span class="math inline">\((\neg B) \Rightarrow (\neg A)\)</span>.</li>
<li><em>Beweise durch Widerspruch</em> zeigen, dass <span class="math inline">\((\neg B) \land A\)</span> falsch ist.</li>
</ul>
<p>Um diese Techniken an einem Beispiel zu erläutern, erinnern wir kurz an folgende <em>Äquivalenzumformungen von Gleichungen</em>:</p>
<ul>
<li>Addition oder Subtraktion einer Zahl auf beiden Seiten der Gleichung, zum Beispiel <span class="math display">\[\begin{equation}
2x + 4 = 10 \Leftrightarrow 2x = 6,
\end{equation}\]</span></li>
<li>Multiplikation mit einer oder Division durch eine von Null verschiedene Zahl auf beiden Seiten der Gleichung, zum Beispiel <span class="math display">\[\begin{equation}
2x = 6 \Leftrightarrow x = 3,
\end{equation}\]</span></li>
<li>Anwendung einer injektiven Funktion auf beiden Seiten der Gleichung, zum Beispiel <span class="math display">\[\begin{equation}
\exp(x) = 2 \Leftrightarrow x = \ln(2),
\end{equation}\]</span></li>
</ul>
<p>sowie an folgende elementaren <em>Äquivalenzumformungen von Ungleichungen</em>:</p>
<ul>
<li>Addition oder Subtraktion einer Zahl auf beiden Seiten der Ungleichung, zum Beispiel <span class="math display">\[\begin{equation}
-2x + 4 \ge 10 \Leftrightarrow -2x \ge 6,
\end{equation}\]</span></li>
<li>Multiplikation mit einer Zahl oder Division durch eine von Null verschiedene Zahl auf beiden Seiten der Ungleichung, wobei die Multiplikation oder Division mit einer negativen Zahl die Umkehrung der Ungleichung impliziert, zum Beispiel <span class="math display">\[\begin{equation}
-2x \ge 6 \Leftrightarrow x \le -3,
\end{equation}\]</span></li>
<li>Anwendung monotoner Funktionen auf beiden Seiten der Ungleichung<br>
<span class="math display">\[\begin{equation}
\exp(x) \ge 2 \Leftrightarrow x \ge \ln(2).
\end{equation}\]</span></li>
</ul>
<p>Damit ausgestattet wollen wir nun folgendes Theorem mithilfe eines direkten Beweises, eines indirekten Beweises und eines Beweises durch Widerspruch beweisen (vgl. <span class="citation" data-cites="arens2018">Arens et al. (<a href="#ref-arens2018" role="doc-biblioref">2018</a>)</span>).</p>
<div id="thm-quadrate-positiver-zahlen" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1.2 (Quadrate positiver Zahlen)</strong></span> Es seien <span class="math inline">\(a\)</span> und <span class="math inline">\(b\)</span> zwei positive Zahlen. Dann gilt <span class="math inline">\(a^2 &lt; b^2 \Rightarrow a &lt; b\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Beweis</em>. </span>Wir geben zunächst einen <em>direkten Beweis</em>. Dazu sei <span class="math inline">\(a^2 &lt; b^2\)</span> die Aussage <span class="math inline">\(A\)</span> und <span class="math inline">\(a &lt; b\)</span> die Aussage <span class="math inline">\(B\)</span>. Dann gilt <span class="math display">\[\begin{equation}
a^2 &lt; b^2
\Leftrightarrow 0 &lt; b^2 - a^2
\Leftrightarrow 0 &lt; (b+a)(b-a)
\Leftrightarrow 0 &lt; (b-a)
\Leftrightarrow a &lt; b.
\end{equation}\]</span> Wir geben nun einen <em>indirekten Beweis</em>. Es sei <span class="math inline">\(a^2 \ge b^2\)</span> die Aussage <span class="math inline">\(\neg A\)</span>. Weiterhin sei <span class="math inline">\(a \ge b\)</span> die Aussage <span class="math inline">\(\neg B\)</span>. Dann gilt <span class="math display">\[\begin{equation}
a \ge b
\Leftrightarrow a^2 \ge ab \land ab \ge b^2
\Leftrightarrow a^2 \ge b^2.
\end{equation}\]</span> Schließlich geben wir einen <em>Beweis durch Widerspruch</em>. Wir zeigen, dazu, dass die Annahme <span class="math inline">\((\neg B) \land A\)</span> auf eine falsche Aussage führt. Es gilt <span class="math display">\[\begin{equation}
a \ge b \land a^2 &lt; b^2 \Leftrightarrow  a^2  \ge ab \land a^2 &lt; b^2   \Leftrightarrow ab \le a^2 &lt; b^2.
\end{equation}\]</span> Weiterhin gilt <span class="math display">\[\begin{equation}
a \ge b \land a^2 &lt; b^2 \Leftrightarrow  ab  \ge b^2 \land a^2 &lt; b^2   \Leftrightarrow a^2 &lt; b^2 \le ab.
\end{equation}\]</span> Insgesamt gilt dann also die falsche Aussage <span class="math display">\[\begin{equation}
ab \le a^2 &lt; b^2 \le ab \Leftrightarrow ab &lt; ab.
\end{equation}\]</span></p>
</div>
</section>
<section id="sec-selbstkontrollfragen-sprache-und-logik" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="sec-selbstkontrollfragen-sprache-und-logik"><span class="header-section-number">1.5</span> Selbstkontrollfragen</h2>
<ol type="1">
<li>Erläutern Sie die Besonderheiten der mathematischen Sprache.</li>
<li>Was sind wesentliche Tätigkeiten zum Erlernen einer Sprache?</li>
<li>Erläutern Sie den Begriff der Definition.</li>
<li>Erläutern Sie den Begriff des Theorems.</li>
<li>Erläutern Sie den Begriff des Beweises.</li>
<li>Geben Sie die Definition einer mathematischen Aussage wieder.</li>
<li>Geben Sie die Definition der Negation einer mathematischen Aussage wieder.</li>
<li>Geben Sie die Definition der Konjunktion zweier mathematischer Aussagen wieder.</li>
<li>Geben Sie die Definition der Disjunktion zweier mathematischer Aussagen wieder.</li>
<li>Geben Sie die Definition der Implikation wieder.</li>
<li>Geben Sie die Definition der Äquivalenz wieder.</li>
<li>Geben Sie die Definition der logischen Äquivalenz wieder.</li>
<li>Erläutern Sie die Begriffe des direkten Beweises, des indirekten Beweises und des Beweises durch Widerspruch.</li>
</ol>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-arens2018" class="csl-entry" role="listitem">
Arens, T., Hettlich, F., Karpfinger, C., Kockelkorn, U., Lichtenegger, K., &amp; Stachel, H. (2018). <em><span>Mathematik</span></em>. <span>Springer Berlin Heidelberg</span>. <a href="https://doi.org/10.1007/978-3-662-56741-8">https://doi.org/10.1007/978-3-662-56741-8</a>
</div>
<div id="ref-blei2017" class="csl-entry" role="listitem">
Blei, D. M., Kucukelbir, A., &amp; McAuliffe, J. D. (2017). Variational <span>Inference</span>: <span>A Review</span> for <span>Statisticians</span>. <em>Journal of the American Statistical Association</em>, <em>112</em>(518), 859–877. <a href="https://doi.org/10.1080/01621459.2017.1285773">https://doi.org/10.1080/01621459.2017.1285773</a>
</div>
<div id="ref-friston2005" class="csl-entry" role="listitem">
Friston, K. (2005). A Theory of Cortical Responses. <em>Philosophical Transactions of the Royal Society B: Biological Sciences</em>, <em>360</em>(1456), 815–836. <a href="https://doi.org/10.1098/rstb.2005.1622">https://doi.org/10.1098/rstb.2005.1622</a>
</div>
<div id="ref-friston2023" class="csl-entry" role="listitem">
Friston, K., Da Costa, L., Sakthivadivel, D. A. R., Heins, C., Pavliotis, G. A., Ramstead, M., &amp; Parr, T. (2023). Path Integrals, Particular Kinds, and Strange Things. <em>Physics of Life Reviews</em>, <em>47</em>, 35–62. <a href="https://doi.org/10.1016/j.plrev.2023.08.016">https://doi.org/10.1016/j.plrev.2023.08.016</a>
</div>
<div id="ref-newton1687" class="csl-entry" role="listitem">
Newton, I. (1687). <em>Philosophiae <span>Naturalis Principia Mathematica</span></em>. <span>Royal Society</span>.
</div>
<div id="ref-ostwald2014" class="csl-entry" role="listitem">
Ostwald, D., Kirilina, E., Starke, L., &amp; Blankenburg, F. (2014). A Tutorial on Variational <span>Bayes</span> for Latent Linear Stochastic Time-Series Models. <em>Journal of Mathematical Psychology</em>, <em>60</em>, 1–19. <a href="https://doi.org/10.1016/j.jmp.2014.04.003">https://doi.org/10.1016/j.jmp.2014.04.003</a>
</div>
<div id="ref-unger2000" class="csl-entry" role="listitem">
Unger, L. (2000). <em>Grundkurs <span>Mathematik</span></em>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link  aria-label=" willkommen"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Willkommen</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Referenzen.html" class="pagination-link" aria-label="Referenzen">
        <span class="nav-page-text">Referenzen</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/dirk-ostwald/dirk-ostwald.github.io/tree/gh-pages/edit/main/101-Sprache-und-Logik.qmd" class="toc-action"><i class="bi bi-github"></i>Seite editieren</a></li></ul></div></div></div></footer></body></html>